export declare const sampleSolidity = "\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface ITestInterface {\n    function interfaceFunction(uint256 value) external returns (bool);\n    event InterfaceEvent(address indexed sender, uint256 value);\n    error InterfaceError(string message);\n}\n\nlibrary MathLib {\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n    \n    function subtract(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"Underflow\");\n        return a - b;\n    }\n}\n\ncontract TestContract is ITestInterface {\n    using MathLib for uint256;\n    \n    struct UserInfo {\n        address userAddress;\n        uint256 balance;\n        mapping(bytes32 => bool) permissions;\n        uint256 lastUpdate;\n    }\n    \n    enum UserRole {\n        None,\n        Basic,\n        Admin,\n        SuperAdmin\n    }\n    \n    uint256 private immutable totalSupply;\n    mapping(address => UserInfo) private users;\n    UserRole[] private roles;\n    \n    event Transfer(\n        address indexed from,\n        address indexed to,\n        uint256 amount\n    );\n    \n    error InsufficientBalance(\n        address user,\n        uint256 available,\n        uint256 required\n    );\n    \n    modifier onlyAdmin() {\n        require(\n            users[msg.sender].permissions[\"ADMIN_ROLE\"],\n            \"Admin only\"\n        );\n        _;\n    }\n    \n    constructor(uint256 _initialSupply) {\n        totalSupply = _initialSupply;\n        users[msg.sender].userAddress = msg.sender;\n        users[msg.sender].balance = _initialSupply;\n        users[msg.sender].permissions[\"ADMIN_ROLE\"] = true;\n    }\n    \n    function transfer(\n        address to,\n        uint256 amount\n    ) external returns (bool) {\n        if (users[msg.sender].balance < amount) {\n            revert InsufficientBalance({\n                user: msg.sender,\n                available: users[msg.sender].balance,\n                required: amount\n            });\n        }\n        \n        users[msg.sender].balance = users[msg.sender].balance.subtract(amount);\n        users[to].balance = users[to].balance.add(amount);\n        \n        emit Transfer(msg.sender, to, amount);\n        return true;\n    }\n    \n    function interfaceFunction(\n        uint256 value\n    ) external override returns (bool) {\n        return value > 0;\n    }\n    \n    fallback() external payable {\n        revert(\"Fallback not allowed\");\n    }\n    \n    receive() external payable {\n        revert(\"Direct deposits not allowed\");\n    }\n}";
